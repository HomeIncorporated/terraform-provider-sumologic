package sumologic

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
)

type SourceRequest struct {
	Source Source `json:"source"`
}

type Source struct {
	Id            int           `json:"id,omitempty"`
	Name          string        `json:"name"`
	SourceType    string        `json:"sourceType,omitempty"`
	ContentType   string        `json:"contentType,omitempty"`
	ScanInterval  int           `json:"scanInterval,omitempty"`
	Paused        bool          `json:"paused"`
	ThirdPartyRef ThirdPartyRef `json:"thirdPartyRef,omitempty"`
}

type ThirdPartyRef struct {
	Resources []AWSCloudTrailResource `json:"resources,omitempty"`
}

type AWSCloudTrailResource struct {
	ServiceType    string                  `json:"serviceType,omitempty"`
	Path           AWSCloudTrailBucketPath `json:"path,omitempty"`
	Authentication AWSAuthentication       `json:"authentication,omitempty"`
}

type AWSCloudTrailBucketPath struct {
	Type           string `json:"type,omitempty"`
	BucketName     string `json:"bucketName,omitempty"`
	PathExpression string `json:"pathExpression,omitempty"`
}

type AWSAuthentication struct {
	Type               string `json:"type,omitempty"`
	AWSAccessKeyId     string `json:"awsId,omitempty"`
	AWSSecretAccessKey string `json:"awsKey,omitempty"`
}

func (s *SumoLogic) GetSourceAWSCloudTrail(collectorId int, source Source) (*Source, string, error) {

	sourceRequest := SourceRequest{
		Source: source,
	}

	body, _ := json.Marshal(sourceRequest)

	relativeUrl, _ := url.Parse(fmt.Sprintf("collectors/%d/sources/%d", collectorId, source.Id))
	url := s.EndpointUrl.ResolveReference(relativeUrl)

	req, err := http.NewRequest("GET", url.String(), bytes.NewBuffer((body)))
	req.Header.Add("Authorization", "Basic "+basicAuth(s.AccessId, s.AccessKey))

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, "", err
	}
	defer resp.Body.Close()

	ResponseBody, _ := ioutil.ReadAll(resp.Body)

	if resp.StatusCode == 401 {
		return nil, "", fmt.Errorf("Authentication Error with Sumo Logic")
	}

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		log.Printf("req: %s", req)
		log.Printf("resp: %s", resp)
		return nil, "", fmt.Errorf("Unknown Error with Sumo Logic")
	}

	var cr = new(SourceRequest)
	err = json.Unmarshal(ResponseBody, &cr)
	if err != nil {
		return nil, "", err
	}

	return &cr.Source, resp.Header.Get("ETag"), nil
}

func (s *SumoLogic) CreateSourceAWSCloudTrail(collectorId int, source Source) (*Source, error) {

	sourceRequest := SourceRequest{
		Source: source,
	}

	body, _ := json.Marshal(sourceRequest)

	relativeUrl, _ := url.Parse(fmt.Sprintf("collectors/%d/sources", collectorId))
	url := s.EndpointUrl.ResolveReference(relativeUrl)

	req, err := http.NewRequest("POST", url.String(), bytes.NewBuffer(body))
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", "Basic "+basicAuth(s.AccessId, s.AccessKey))

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	responseBody, _ := ioutil.ReadAll(resp.Body)

	if resp.StatusCode == 401 {
		return nil, fmt.Errorf("Authentication Error with Sumo Logic")
	}

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		log.Printf("body: %s", body)
		log.Printf("req: %s", req)
		log.Printf("resp: %s", resp)
		return nil, fmt.Errorf("Unknown Error with Sumo Logic")
	}

	var cr = new(SourceRequest)
	err = json.Unmarshal(responseBody, &cr)
	if err != nil {
		return nil, err
	}

	return &cr.Source, nil
}

func (s *SumoLogic) UpdateSourceAWSCloudTrail(collectorId int, source Source, etag string) (*Source, error) {

	sourceRequest := SourceRequest{
		Source: source,
	}

	body, _ := json.Marshal(sourceRequest)

	relativeUrl, _ := url.Parse(fmt.Sprintf("collectors/%d/sources/%d", collectorId, source.Id))
	url := s.EndpointUrl.ResolveReference(relativeUrl)

	req, err := http.NewRequest("PUT", url.String(), bytes.NewBuffer((body)))
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", "Basic "+basicAuth(s.AccessId, s.AccessKey))
	req.Header.Add("If-Match", etag)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	ResponseBody, _ := ioutil.ReadAll(resp.Body)

	if resp.StatusCode == 401 {
		return nil, fmt.Errorf("Authentication Error with Sumo Logic")
	}

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		log.Printf("body: %s", body)
		log.Printf("req: %s", req)
		log.Printf("resp: %s", resp)
		return nil, fmt.Errorf("Unknown Error with Sumo Logic")
	}

	var cr = new(SourceRequest)
	err = json.Unmarshal(ResponseBody, &cr)
	if err != nil {
		return nil, err
	}

	return &cr.Source, nil
}

func (s *SumoLogic) DeleteSourceAWSCloudTrail(collectorId int, id int) error {
	c, _ := url.Parse(fmt.Sprintf("collectors/%d/sources/%d", collectorId, id))
	req, err := http.NewRequest("DELETE", s.EndpointUrl.ResolveReference(c).String(), nil)
	req.Header.Add("Authorization", "Basic "+basicAuth(s.AccessId, s.AccessKey))

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode == 401 {
		return fmt.Errorf("Authentication Error with Sumo Logic")
	}

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		log.Printf("req: %s", req)
		log.Printf("resp: %s", resp)
		return fmt.Errorf("Unknown Error with Sumo Logic")
	}

	return nil
}
